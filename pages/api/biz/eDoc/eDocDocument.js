`use strict`

import logger from "../../winston/logger"
import * as constants from '@/components/constants'
import * as database from "../database/database"
import * as dynamicSql from '../dynamicSql'
import * as commonFunctions from '@/components/commonFunctions'

const executeService = async (txnId, jRequest) => {
    var jResponse = {};

    try {
        switch (jRequest.commandName) {
            case constants.commands.EDOC_DOCUMENT_UPSERT_ONE:
                jResponse = await upsertOne(txnId, jRequest);
                break;
            case constants.commands.EDOC_DOCUMENT_SELECT_ONE:
                jResponse = await selectOne(txnId, jRequest);
                break;
            case constants.commands.EDOC_DOCUMENT_DELETE_ONE:
                jResponse = await deleteOne(txnId, jRequest);
                break;
            case constants.commands.EDOC_USER_DOCUMENT_SELECT_ALL: // user all documents
                jResponse = await selectUserAll(txnId, jRequest);
                break;
            case constants.commands.EDOC_ADMIN_DOCUMENT_SELECT_ALL: // admin & public documents
                jResponse = await selectAdminAll(txnId, jRequest);
                break;
            case constants.commands.EDOC_DOCUMENT_AUTO_GENERATE_DOCUMENT:
                jResponse = await autoGenerateDocument(txnId, jRequest);
              break;
            default:
                break;
        }
    } catch (error) {
        logger.error(`message:${error.message}\n stack:${error.stack}\n`);
    } finally {
        return jResponse;
    }
}


const upsertOne = async (txnId, jRequest) => {
  const jResponse = {};
  let isInsert = null;

  try {
    jResponse.commandName = jRequest.commandName;

    if (!jRequest.documentData) {
      jResponse.error_code = -2;
      jResponse.error_message = `${constants.messages.REQUIRED_FIELD} [documentData]`;
      return jResponse;
    }

    if (!jRequest.documentData.id) {
      jRequest.documentData.id = commonFunctions.generateUUID();

      if (!jRequest.documentData.runtime_data.title) {
        jRequest.documentData.runtime_data.title = "New document";
      }

      if (!jRequest.documentData.runtime_data.description) {
        jRequest.documentData.runtime_data.description = "New document";
      }

      isInsert = true; // insert
    } else {
      isInsert = false; // update
    }

    if (!jRequest.documentData.runtime_data.title) {
      jRequest.documentData.runtime_data.title = constants.messages.EMPTY_STRING;
    }

    // ✅ pages는 필수 JSON
    if (!jRequest.documentData.pages) {
      jRequest.documentData.pages = [];
    }

    if (isInsert) {
      // INSERT
      const sql = await dynamicSql.getSQL00('insert_TB_DOC_DOCUMENT', 1);
      const insertResult = await database.executeSQL(sql, [
        jRequest.systemCode,
        jRequest.documentData.id,
        jRequest.documentData.runtime_data.title,
        jRequest.documentData.runtime_data.description,
        1, // version
        jRequest.userId,
        JSON.stringify(jRequest.documentData.runtime_data || {}),
        JSON.stringify(jRequest.documentData.pages || []),
        jRequest.documentData.runtime_data.menu_path,
      ]);

      if (insertResult.rowCount !== 1) {
        jResponse.error_code = -1;
        jResponse.error_message = constants.messages.FAILED_TO_SAVE_DATA;
        return jResponse;
      }
    } else {
      // UPDATE
      const sql = await dynamicSql.getSQL00('update_TB_DOC_DOCUMENT', 1);
      const updateResult = await database.executeSQL(sql, [
        jRequest.systemCode,
        jRequest.documentData.id,
        jRequest.documentData.runtime_data.title,
        jRequest.documentData.runtime_data.description,
        jRequest.userId,
        JSON.stringify(jRequest.documentData.runtime_data || {}),
        JSON.stringify(jRequest.documentData.pages || []),
        jRequest.documentData.runtime_data.menu_path,
      ]);

      if (updateResult.rowCount !== 1) {
        jResponse.error_code = -1;
        jResponse.error_message = constants.messages.FAILED_TO_SAVE_DATA;
        return jResponse;
      }
    }

    jResponse.error_code = 0;
    jResponse.error_message = constants.messages.SUCCESS_SAVED;
    jResponse.documentData = jRequest.documentData;
  } catch (e) {
    logger.error(e);
    jResponse.error_code = -1;
    jResponse.error_message = e.message;
  } finally {
    return jResponse;
  }
};


const selectOne = async (txnId, jRequest) => {
  const jResponse = {};

  try {
    jResponse.commandName = jRequest.commandName;

    if (!jRequest.documentId) {
      jResponse.error_code = -2;
      jResponse.error_message = `${constants.messages.REQUIRED_FIELD} [documentData.id]`;
      return jResponse;
    }

    // ✅ TB_DOC_DOCUMENT에서 pages 포함 가져오기
    const sql = await dynamicSql.getSQL00('select_TB_DOC_DOCUMENT', 1);
    const select_TB_DOC_DOCUMENT = await database.executeSQL(sql, [
      jRequest.systemCode,
      jRequest.documentId
    ]);

    if (select_TB_DOC_DOCUMENT.rowCount < 1) {
      jResponse.error_code = 0;
      jResponse.error_message = constants.messages.NO_DATA_FOUND;
      return jResponse;
    }

    const row = select_TB_DOC_DOCUMENT.rows[0];

    const documentData = {
      id: row.id,
      runtime_data: row.runtime_data,
      pages: row.pages || [],
    };

    jResponse.documentData = documentData;
    jResponse.error_code = 0;
    jResponse.error_message = constants.messages.EMPTY_STRING;
  } catch (e) {
    logger.error(e);
    jResponse.error_code = -1;
    jResponse.error_message = e.message;
  } finally {
    return jResponse;
  }
};

const deleteOne = async (txnId, jRequest) => {
  const jResponse = {};

  try {
    jResponse.commandName = jRequest.commandName;

    if (!jRequest.documentId) {
      jResponse.error_code = -2;
      jResponse.error_message = `${constants.messages.REQUIRED_FIELD} [documentId]`;
      return jResponse;
    }

    // TB_DOC_DOCUMENT 삭제만 수행
    const sql = await dynamicSql.getSQL00('delete_TB_DOC_DOCUMENT', 1);
    const delete_TB_DOC_DOCUMENT = await database.executeSQL(sql, [
      jRequest.systemCode,
      jRequest.documentId
    ]);

    jResponse.error_code = 0;
    jResponse.error_message = constants.messages.SUCCESS_DELETED;
    jResponse.documentData = jRequest.documentData; // optional
  } catch (e) {
    logger.error(e);
    jResponse.error_code = -1;
    jResponse.error_message = e.message;
  } finally {
    return jResponse;
  }
};

const selectUserAll = async (txnId, jRequest) => {
    var jResponse = {};
    
    try {
        jResponse.commanaName = jRequest.commandName;
        
        // select TB_DOC_DOCUMENT
        var sql = null
        sql = await dynamicSql.getSQL00('select_TB_DOC_DOCUMENT', 2);
        var select_TB_DOC_DOCUMENT = await database.executeSQL(sql,
            [
                jRequest.systemCode,
                jRequest.userId   
            ]);

        jResponse.documentList = select_TB_DOC_DOCUMENT.rows;

        jResponse.error_code = 0;
        jResponse.error_message = constants.messages.EMPTY_STRING
    } catch (e) {
        logger.error(e);
        jResponse.error_code = -1; // exception
        jResponse.error_message = e.message
    } finally {
        return jResponse;
    }
};

// 관리자가 작성한 공용문서 전체 목록 조회
const selectAdminAll = async (txnId, jRequest) => {
    var jResponse = {};
    
    try {
        jResponse.commanaName = jRequest.commandName;
        
        // select TB_DOC_DOCUMENT
        var sql = null
        sql = await dynamicSql.getSQL00('select_TB_DOC_DOCUMENT', 3);
        var select_TB_DOC_DOCUMENT = await database.executeSQL(sql,
            [
                jRequest.systemCode,
            ]);

        jResponse.documentList = select_TB_DOC_DOCUMENT.rows;

        jResponse.error_code = 0;
        jResponse.error_message = constants.messages.EMPTY_STRING
    } catch (e) {
        logger.error(e);
        jResponse.error_code = -1; // exception
        jResponse.error_message = e.message
    } finally {
        return jResponse;
    }
};

// 관리자가 작성한 공용문서 전체 목록 조회 및 AI 문서 자동 생성
// lib/autoGenerateDocument.js
export const autoGenerateDocument = async (txnId, jRequest) => {
  let jResponse = {};
  const serverUrl = "https://api.openai.com/v1/chat/completions";

  try {
    const prompt = `
문서 제목: ${jRequest.instructionInfo.title}
지시사항: ${jRequest.instructionInfo.instructions}

너는 문서 작성 도우미야. 
JSON 형식으로만 문서를 만들어야 하며, 
필요에 따라 아래 7개 기본 컴포넌트를 사용할 수 있어야 한다:
1. 텍스트(text) : 텍스트로 문장들을 입력하고 단락을 구성함, 단락내에 여러 문장을 넣을 수 있고 줄바꿈이 가능하므로 동일 단락이면 한개의 텍스트 컴포넌트를 사용.
문장이 여러개라도 특별한 이유없이 여러개의 텍스트 컴포넌트를 사용할 필요가 없음.
2. 체크리스트(checklist): 여러 종류의 옵션이 있고 선택여부 체크를 표현할 필요가 있을때에만 사용.
3. 입력란(input): 텍스트로 단일 문장을 입력할 수 있게 하는 경우에 사용.
4. 이미지(image): 문서에 이미지를 삽입함. 웹상에 있는 이미지도 정확한 URL을 설정하여 문서에서 표시.
5. 버튼(button): 사용자가 클릭하게 할 수 있고 필요에 따라 외부 Restful API를 호출할 속성값들을 설정하여 호출.
6. 테이블(table): 문서내에 테이블을 삽입하고 표 데이터를 구성하고 표시.
7. 동영상(video) : 문서에 동영상을 삽입함. 웹상에 있는 동영상도 정확한 URL을 설정하여 문서에서 재생-.

JSON 문서 포맷 예시 (7개 컴포넌트 모두 포함):
{
  "id": null,
  "runtime_data": {
    "title": "문서 제목",
    "description": "문서 설명",
    "isPublic": false,
    "backgroundColor": "#ffffff",
    "padding": 1
  },
  "pages": [
    {
      "id": "page-1",
      "components": [
        {
          "id": "GUID",
          "name": "텍스트",
          "type": "text",
          "description": "텍스트 컴포넌트",
          "template_json": { "type": "text", "content": "텍스트 내용", "textAlign": "left" },
          "runtime_data": { "content": "텍스트 내용", "fontSize": 12, "forceNewLine": true, "textAlign": "left" }
        },
        {
          "id": "GUID",
          "name": "체크리스트",
          "type": "checklist",
          "description": "체크리스트 컴포넌트",
          "template_json": { "type": "checklist", "itemCount": 3, "textAlign": "left" },
          "runtime_data": { "items": [{"label":"항목 1","checked":false},{"label":"항목 2","checked":false},{"label":"항목 3","checked":false}], "forceNewLine": true }
        },
        {
          "id": "GUID",
          "name": "입력란",
          "type": "input",
          "description": "사용자 입력란 컴포넌트",
          "template_json": { "type": "input", "textAlign": "left", "placeholder":"값을 입력하세요" },
          "runtime_data": { "placeholder": "여기에 값을 입력하세요", "forceNewLine": true }
        },
        {
          "id": "GUID",
          "name": "이미지",
          "type": "image",
          "description": "이미지 컴포넌트",
          "template_json": { "src": "", "type": "image" },
          "runtime_data": { "src": "", "forceNewLine": true }
        },
        {
          "id": "GUID",
          "name": "버튼",
          "type": "button",
          "description": "버튼 컴포넌트",
          "template_json": { "type": "button", "buttonText": "버튼" },
          "runtime_data": { "buttonText": "버튼", "forceNewLine": true }
        },
        {
          "id": "GUID",
          "name": "테이블",
          "type": "table",
          "description": "테이블 컴포넌트",
          "template_json": { "cols": 3, "rows": 3, "type": "table" },
          "runtime_data": { "data":[["","",""],["","",""],["","",""]], "forceNewLine": true }
        },
        {
          "id": "GUID",
          "name": "동영상",
          "type": "video",
          "description": "동영상 컴포넌트",
          "template_json": { "url": "", "type": "video", "title": "영상 제목" },
          "runtime_data": { "url": "", "title": "영상 제목", "forceNewLine": true }
        }
      ],
      "runtime_data": { "padding": 24, "alignment": "center", "pageMargin": 1 }
    }
  ]
}
- 반드시 JSON만 반환하고, 코드나 주석은 포함하지 말것
`;

    const aiResponse = await fetch(serverUrl, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${jRequest.instructionInfo.apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: jRequest.instructionInfo.model,
        messages: [
          {
            role: "system",
            content: "너는 문서 작성 도우미야. JSON 형식으로만 문서를 만들어야 한다.",
          },
          { role: "user", content: prompt },
        ],
        temperature: 0.7,
      }),
    });

    const resJson = await aiResponse.json();
    const content = resJson.choices?.[0]?.message?.content
      ? resJson.choices[0].message.content
      : "{}";

    if (resJson.error) {
      jResponse = {
        commanaName: jRequest.commandName,
        error_code: -1,
        error_message: `${resJson.error.message}`,
      };
    } else {
      jResponse = {
        commanaName: jRequest.commandName,
        documentData: JSON.parse(content),
        error_code: 0,
        error_message: "",
      };
    }
  } catch (e) {
    jResponse = {
      commanaName: jRequest.commandName,
      error_code: -1,
      error_message: `${e}`,
    };
  }

  return jResponse;
};



export { executeService };